<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[{ theWayOfCoding }]]></title>
  <subtitle><![CDATA[Weyou's Notes]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-04-20T07:31:32.704Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Kelvin You]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux init系统学习笔记]]></title>
    <link href="http://yoursite.com/2014/08/30/Linux%20init%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2014/08/30/Linux init系统学习笔记/</id>
    <published>2014-08-30T06:57:45.000Z</published>
    <updated>2015-04-20T07:31:32.704Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是init系统">什么是init系统</h2><p>Linux的启动过程大致如下:<br>BIOS -&gt; Boot Loader -&gt; Load Kernel -&gt; Kernel初始化 -&gt; 创建pid=1的init进程<br><a id="more"></a><br>init进程有以下特点：</p>
<ul>
<li>以守护进程方式存在，PID是1，是所有其他进程的祖先</li>
<li>负责组织和运行许多独立的相关的初始化化工作 </li>
<li>按照预设的运行模式（runlevel）启动shell或者X图形界面</li>
</ul>
<p>init进程和与其相关的工作过程被称为<strong>init系统</strong>。</p>
<h2 id="init系统的主要分类">init系统的主要分类</h2><p>传统的init: BSDinit, Sysvinit<br>现代的init: UpStart, Systemd</p>
<h2 id="BSDinit">BSDinit</h2><p>运行<strong>/etc/rc</strong>，然后启动基于文本模式的终端(getty)或者基于图形界面的终端(窗口系统，如X)， 所有的工作都在rc中进行。</p>
<p>BSDinit简单且易于手动编辑。但如果第三方软件需要在启动过程执行它自身的初始化脚本，它必须修改已经存在的启动脚本，一旦这种过程中有一个小错误，都将导致系统无法正常启动。</p>
<p>现代的BSD风格的init使用rc.local和rc.d中的子脚本来降低系统无法启动的风险。</p>
<h2 id="Sysvinit">Sysvinit</h2><p>这种init系统被广泛使用，源于System V系列的UNIX， 是System V相兼容的，称为sysvinit。<br>Sysvinit读取/etc/inittab 文件，获取运行模式及工作范围，然后利用<em>Shell脚本</em>，<em>文件命名规则</em>和<em>软链接</em>来实现不同的runlevel。<br>通常会有 8 种运行模式，即运行模式 0 到 6 和 S 或者 s。  每个发行版都有不同的定义，但 0， 1， 6的定义通常是一致的：</p>
<ul>
<li>0 关机</li>
<li>1 单用户模式</li>
<li>6 重启</li>
</ul>
<p>可以用一下命令来获取当前的运行模式<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>runlevel</span><br><span class="line"><span class="variable">$ </span>who -r</span><br></pre></td></tr></table></figure></p>
<h3 id="工作流程">工作流程</h3><p>/etc/rc.d/rc.sysinit  -&gt; /etc/rc.d/rc 和/etc/rc.d/rcX.d/ -&gt; /etc/rc.d/rc.local </p>
<p>首先执行<strong>rc.sysinit</strong>，主要有完成以下工作。</p>
<ul>
<li>激活 udev 和 selinux</li>
<li>设置定义在/etc/sysctl.conf 中的内核参数</li>
<li>设置系统时钟</li>
<li>加载keymaps</li>
<li>使能交换分区</li>
<li>设置主机名(hostname)</li>
<li>根分区检查和remount</li>
<li>激活 RAID 和 LVM 设备</li>
<li>开启磁盘配额</li>
<li>检查并挂载所有文件系统</li>
<li>清除过期的 locks 和 PID 文件</li>
</ul>
<p>然后执行<strong>/etc/rc.d/rc</strong>脚本， rc脚本根据runlevel去<strong>/etc/rc.d/rcX.d</strong>（(X 代表运行级别 0-6）去找到所有S打头的启动脚本按照S后面的数字顺序执行。这些脚本除了<strong>SXXlocal</strong>以外，其他都是/etc/init.d下面服务进程的启动脚本的软链接。</p>
<p><strong>SXXlocal</strong>是<strong>/etc/rc.d/rc.local</strong>脚本的的软链接。S后面的数字XX比较靠后，所以一般在所有脚本的最后运行。之所以单独提出来，是因为通常一些用户希望跟随系统启动的程序可以在这里加载。</p>
<p>如果是GUI模式的runlevel，最后还要启动GUI管理器</p>
<ul>
<li>X Display Manager</li>
</ul>
<p>当<strong>关闭系统</strong>的时候，Sysvinit也会执行<strong>/etc/rc.d/rcX.d</strong>下面的脚本，与启动不同的是，关闭的时候执行的是K打头的启动脚本， 同样K后面的数字决定了执行的顺序。</p>
<h3 id="管理命令">管理命令</h3><ul>
<li>service <name> start</name></li>
<li>service <name> stop</name></li>
<li>service <name> restart</name></li>
<li>service <name> reload</name></li>
</ul>
<h3 id="总结">总结</h3><p>概念简单，直接用shell脚本，不需要学习特殊语法。顺序执行所以易于排错。但是缺点也是依赖于脚本，导致启动比较慢，已不适应移动设备快速启动的需求。</p>
<h2 id="UpStart">UpStart</h2><p>Sysvinit适合用在服务器环境， 服务器环境不会频繁重启，也不会频繁增减外设。<br>而在Linux2.6时代，桌面系统开始成熟，频繁的重启则使人们对重启的时间有了要求，外设的热插拔导致只能顺序执行的Sysvinit无法胜任。<br>而基于事件驱动模型的UpStart则很好的解决了这些问题。UpStart 可以：</p>
<ul>
<li>更快地启动系统</li>
<li>当新硬件被发现时动态启动服务</li>
<li>硬件被拔除时动态停止服务</li>
</ul>
<p>UpStart成为Ubuntu默认的init系统。</p>
<h3 id="基本概念">基本概念</h3><p>首先要理解两个概念： <strong>Job</strong>和<strong>Event</strong>。 每个Job 都等待一个或多个事件，一旦事件发生，UpStart就触发该 job 完成相应的工作</p>
<h4 id="Job">Job</h4><p>Job是一个工作单元，一个任务或者一个服务。可以理解为 sysvinit 中的一个服务脚本。有三种类型</p>
<ul>
<li>task job<br>一定时间内会执行完毕的任务。</li>
<li>service job<br>后台服务进程，一般是不会退出的。</li>
<li>abstract job<br>UpStart内部使用，不需要关心。</li>
</ul>
<p>还可以从Job的工作范围分为2类：</p>
<ul>
<li>System Job<br>系统初始化使用的Job</li>
<li>Session Job<br>用户会话初始化使用的Job</li>
</ul>
<table>
<thead>
<tr>
<th>状态名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Waiting</td>
<td>初始状态</td>
</tr>
<tr>
<td>Starting</td>
<td>Job 即将开始</td>
</tr>
<tr>
<td>pre-start</td>
<td>执行 pre-start 段，即任务开始前应该完成的工作</td>
</tr>
<tr>
<td>Spawned</td>
<td>准备执行 script 或者 exec 段</td>
</tr>
<tr>
<td>post-start</td>
<td>执行 post-start 动作</td>
</tr>
<tr>
<td>Running</td>
<td>运行阶段</td>
</tr>
<tr>
<td>pre-stop</td>
<td>执行 pre-stop 段</td>
</tr>
<tr>
<td>Stopping</td>
<td>interim state set after pre-stop section processed</td>
</tr>
<tr>
<td>Killed</td>
<td>任务即将被停止</td>
</tr>
<tr>
<td>post-stop</td>
<td>执行 post-stop 段</td>
</tr>
</tbody>
</table>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocupstart-states.png" alt="Job的状态转换"></p>
<ul>
<li>菱形的节点代表了静止的状态</li>
<li>椭圆形的节点代表的状态中可以执行一些操作</li>
<li>矩形的节点代表了进入下一个状态之前将会发出的Event</li>
<li>所有的节点根据Event发出的时间阶段被划分成了4个虚拟状态(Starting/Started/Stopping/Stopped)来反应</li>
<li>从节点出发的绿色箭头导向的目标为start</li>
<li>从节点出发的红色箭头导向的目标为stop</li>
</ul>
<p>当工作的状态即将发生变化的时候，UpStart进程会发出相应的事件（event）<br>其中有四个状态会引起UpStart进程发送相应的事件，表明该Job的相应变化：</p>
<ul>
<li>Starting</li>
<li>Started</li>
<li>Stopping</li>
<li>Stopped</li>
</ul>
<p>而其它的状态变化不会发出事件</p>
<h4 id="Event">Event</h4><p>事件以系统通知消息的形式存在。 当一个Event发生时，所有的Upstart组件都会得到通知。</p>
<p>Event有三种类型</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Synchronized</th>
<th>Result Available</th>
</tr>
</thead>
<tbody>
<tr>
<td>Signals</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Methods</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Hooks</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>init支持的Event各个发行版都有不同的定义， 可以用以下命令来查看：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">7</span> upstart-<span class="keyword">events</span></span><br></pre></td></tr></table></figure></p>
<h3 id="工作流程-1">工作流程</h3><p>系统初始化时，init 进程开始运行，init进程自身会发出不同的Event，这些最初的事件会触发一些Job运行。每个Job运行过程中会释放不同的Event，这些Event又将触发新的Job运行。如此反复，直到整个系统正常运行起来。</p>
<h5 id="Job的配置文件">Job的配置文件</h5><p>配置文件存在在/etc/init下面， 有点类似于Sysvinit的/etc/init.d<br>配置文件定义了一个Job，可以由以下几个字段组成：</p>
<ul>
<li>author/description<br> 这两个字段顾名思义，无需赘言</li>
<li>expect<br>用于告知UpStart这个任务会fork几次， UpStart以此来记录正真的PID用于任务的管理<ul>
<li>expect fork：表示进程只会 fork 一次</li>
<li>expect daemonize：表示进程会 fork 两次<br>这个字段很重要， 如果设置错误，可能会影响到Job的停止功能。</li>
</ul>
</li>
<li><p>script/exec<br>Job的具体内容，如果是运行一段shell脚本， 就用script</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">script</span></span><br><span class="line">&lt;...shell <span class="keyword">script</span>...&gt;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">script</span></span><br></pre></td></tr></table></figure>
<p>如果是运行一个程序</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec &lt;command&gt; &lt;args&gt;<span class="keyword">...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>start on<br>定义了触发Job的所有事件，语法：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start on EVENT [[KEY=]VALUE]<span class="keyword">...</span> [and|or...]</span><br></pre></td></tr></table></figure>
<p>用 KEY=VALUE 来表示额外的条件，一般是某个环境变量(KEY)和特定值(VALUE)进行比较。比如:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start <span class="function_start"><span class="keyword">on</span></span> (<span class="keyword">local</span>-filesystems <span class="keyword">and</span> net-device-up IFACE!=lo)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  如果只有一个变量，或者变量的顺序已知，则 KEY 可以省略。比如：<br>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="literal">on</span> runlevel<span class="sqbracket"> [2345]</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>stop on<br>类似于start on， 定义了需要Job停止的所有事件</li>
</ul>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocimage004[1].png" alt="UpStart的启动过程"><br>UpStart并没有运行模式的概念，但是为了兼容原有的软件， UpStart用Job模拟了SysV的运行模式, 可以参看/etc/init/rc-sysinit.conf和/etc/init/rc.conf.<br>这就是为什么Ubuntu下定义在/etc/init.d的服务还是可以正常工作的原因</p>
<h3 id="管理命令-1">管理命令</h3><p>最主要的命令是<strong>initctl</strong>, 常用的简化命令有：</p>
<ul>
<li>start <job></job></li>
<li>stop <job></job></li>
<li>restart <job></job></li>
<li>reload <job></job></li>
</ul>
<p>这些命令都是<strong>initctl</strong>命令的软链接。</p>
<p>此外还可以使用 initctl 的 emit 命令从命令行发送一个事件用于排错。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initctl <span class="keyword">emit</span> &lt;<span class="keyword">event</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-1">总结</h3><p>并发进程让启动时间更短，支持事件驱动服务的启停，兼容现有的Sysvinit的服务。</p>
<h2 id="Systemd">Systemd</h2><p>Systemd是后起之秀， 和UpStart一样, Systemd提供了和Sysvinit以及LSB initscripts兼容的特性。不同的是Systemd进一步提高了服务启动的并发性。</p>
<h3 id="工作流程-2">工作流程</h3><p>先看一下UpStart 对 Sysvinit的改进</p>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocimage003[1].jpg" alt="UpStart 对 SysVinit 的改进"><br>*原文章配图有误， 已更正</p>
<ul>
<li>C和D依赖于B， B依赖于A</li>
<li>F依赖于E</li>
<li>G不依赖任何服务</li>
</ul>
<p>可以看到Sysvinit中， 没有依赖关系的服务也必须顺序启动，浪费了很多启动时间。<br>而对于UpStart来说，有依赖关系的服务必须先启动，只有不相关的服务才可以并行启动， 比如A，E，G可以同时启动，C和D也是同时启动。</p>
<p>在看一下Systemd对Sysvinit的改进<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocimage005.jpg" alt="Systemd对 SysVinit 的改进"><br>可以看到Systemd几乎所有的服务都可以并行启动，即使他们之间有依赖关系。这是怎么做到的呢？</p>
<p>Systemd可以用以下方式来解除依赖：</p>
<ul>
<li><p>Socket activation<br>如果服务A用套接字S1提供自己的服务，往常的方式是B必须等到A启动以后才能连接套接字S1. 现在Systemd可以先单独创建一个套接字S1，然后让A和B同时启动，如果B启动完成后，A还没有完成，B发向S1的请求会被缓存，直到A完成启动后接管套接字S1的处理。 这种解除依赖的方式类似于<code>inetd</code>，利用了父子进程之间套接字可以继承的原理。</p>
</li>
<li><p>D-Bus activation<br>与Socket activation类似，只不过Socke换成D-Bus</p>
</li>
<li><p>autofs<br>文件系统的挂载非常耗时，Systemd借鉴了autofs的设计思路。即使文件系统挂载点未准备就绪， 那些依赖于这个挂载点的服务也可以并发启动，只不过<code>open()</code>系统调用会被挂起，然后等待真正的挂载操作完成。 之后让<code>open()</code>操作返回。</p>
<blockquote>
<p>当然对于”/“根目录的依赖实际上一定还是要串行执行，因为 systemd 自己也存放在/之下，必须等待系统根目录挂载检查好。</p>
</blockquote>
</li>
</ul>
<p>如果以上3种手段解决不了的依赖， Systemd也只能让它们顺序执行了。</p>
<h3 id="Systemd的特点">Systemd的特点</h3><ul>
<li>按需启动，只有在正真用到的时候才启动相关服务</li>
<li>使用cgroup来跟踪管理进程，免除了UpStart设定fork次数的困扰</li>
<li>启动挂载点和自动挂载的管理</li>
<li>事务性依赖关系管理</li>
<li>系统快照和恢复</li>
<li>日志服务</li>
</ul>
<h3 id="Systemd的争议">Systemd的争议</h3><p>Systemd在Linux社区一直饱受争议，主要是因为Systemd接管了原本是inetd, syslog, crond, udev等独立进程负责的事情。 与<em>Unix的哲学</em>（只做一件事，并且把它做好）相违背。并且因为接管的事情过多， 导致对别的平台（比如FreeBSD）无法支持。</p>
<h2 id="References">References</h2><p><a href="http://zh.wikipedia.org/zh-cn/Init" target="_blank" rel="external">维基百科init词条</a><br><a href="http://upstart.ubuntu.com" target="_blank" rel="external">UpStart Wiki</a><br><a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="external">浅析 Linux 初始化 init 系统</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是init系统">什么是init系统</h2><p>Linux的启动过程大致如下:<br>BIOS -&gt; Boot Loader -&gt; Load Kernel -&gt; Kernel初始化 -&gt; 创建pid=1的init进程<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pyro4学习笔记]]></title>
    <link href="http://yoursite.com/2014/01/10/Pyro4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2014/01/10/Pyro4学习笔记/</id>
    <published>2014-01-10T09:32:27.000Z</published>
    <updated>2015-04-20T07:59:16.415Z</updated>
    <content type="html"><![CDATA[<p> <a href="https://pythonhosted.org/Pyro4/" target="_blank" rel="external">Pyro4</a>是一个能够通过网络来调用远程Python对象的库， 因为是纯Python实现的，具有良好的跨平台的特性， 可以用于分布式计算。这个库同时支持Python2与Python3。<br><a id="more"></a></p>
<h2 id="为什么要使用Pyro">为什么要使用Pyro</h2><p>传统RPC机制如SOAP, JSON-RPC, xmlrpc等只能支持基本的数据类型，而Pyro的优势在于支持所有的Python数据类型。比如dict里的key如果是非字符串类型的， 传统RPC机制就没法处理了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>更不用谈这个混合类型的数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p>对object类型更是无能为力， 只能先<code>pickle</code>再<code>unpickle</code>。<br>Pyro的另外一个优势而且具有相当高的效率。</p>
<p>但优点也同时是它的缺点，因为这个库支持很多Pyhon的特性，所以客户端和服务器端不能够跨语言调用（已有.net和java的版本）， 有跨语言需求的只能选择传统RPC机制。</p>
<h2 id="一个简单示例">一个简单示例</h2><p>hello.py包含了一个普通的Python类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> platform, hashlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.attr = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, welcome to &#123;&#125;."</span>.format(platform.node())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcMD5</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hashlib.md5(s.encode(<span class="string">'utf8'</span>)).hexdigest()</span><br></pre></td></tr></table></figure>
<p>现在这个类只能被本地的Python程序调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> hello</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj = hello.Hello()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.attr <span class="comment"># access attribute</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.sayHello()    <span class="comment"># access method</span></span><br><span class="line"><span class="string">'Hello, welcom to weyou-desktop.'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.calcMD5(<span class="string">'abc'</span>)</span><br><span class="line"><span class="string">'900150983cd24fb0d6963f7d28e17f72'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Pyro加持的示例">Pyro加持的示例</h2><p>如果想要在任何地方都能访问到Hello对象， 就需要Pyro的帮忙了。大致工作流程是这样的：</p>
<h3 id="服务​端">服务​端</h3><p>将要远程访问的Python对象注册到Pyro的daemon里面， 然后在远程运行这个daemon。 daemon会接收客户端发来的远程调用指令， 然后执行实际的method，再把<strong>执行结果</strong>用serpent/pickle等协议来封装， 通过网络传输给调用端。</p>
<p>Python对象Pyro化的过程非常的方便， 只需要添加几行代码就可以做到。 一个对象可以很方便的在远程调用和本地调用之间切换， 换句话说， 你的软件可以是本地运行的， 也可以方便的把某个组件用Pyro来切换成远程调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pyro4</span><br><span class="line"><span class="keyword">import</span> platform, hashlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.attr = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, welcome to &#123;&#125;."</span>.format(platform.node())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcMD5</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hashlib.md5(s.encode(<span class="string">'utf8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line">hello = Hello()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为Pyro相关的代码</span></span><br><span class="line">daemon=Pyro4.Daemon(host=<span class="string">'server-desktop'</span>, port=<span class="number">9999</span>)     <span class="comment"># 创建一个Pyro的Daemon, 其中server-desktop是server</span></span><br><span class="line">uri=daemon.register(hello)                 <span class="comment"># 把hello对象注册到Pyro的Daemon</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Ready. Object uri ="</span>, uri           <span class="comment"># 打印出生成的uri， 这个uri可以用于客户端的连接</span></span><br><span class="line">daemon.requestLoop()                       <span class="comment"># 启动Daemon并等待客户端的调用指令。</span></span><br></pre></td></tr></table></figure>
<p>运行服务端：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ready. Object uri = <span class="string">PYRO:</span>obj_edb9e53007ce4713b371d0dc6a177955<span class="annotation">@server</span>-<span class="string">desktop:</span><span class="number">9999</span></span><br></pre></td></tr></table></figure></p>
<p>打印出的<code>uri</code>就是<code>hello</code>这个Pyro对象在网络上的唯一标识。这个uri是由<em>Object Id</em>，<em>Server Address</em>以及<em>Server Port</em>三部分组成，很显然这个<code>uri</code>告诉了客户端从哪里可以找到这个对象。 有了这个<code>uri</code>， 我们就可以通过客端来调用<code>hello</code>对象了。</p>
<p>注意到默认的<code>uri</code>中的<em>Object Id</em>部分是随机自动生成的，为了便于记忆，我们也可以这样来自定义一个<em>Object Id</em>：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri=daemon.<span class="function"><span class="title">register</span><span class="params">(hello, objectId=<span class="string">"hello.test"</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样得到的hello对象的uri是：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ready. Object uri = <span class="string">PYRO:</span> hello.test<span class="annotation">@server</span>-<span class="string">desktop:</span><span class="number">9999</span></span><br></pre></td></tr></table></figure></p>
<h3 id="客户端">客户端</h3><p>本地对远程对象的<strong>调用指令</strong>将会用serpent/pickle等协议来封装，然后通过网络来传输到远端Daemon， 等待远程服务端执行完毕，接收远程服务端返回的结果。</p>
<p>为了能够访问到Pyro的object， 必须要知道哪里可以找到这个object， 我们已经知道Pyro对象的地址是用uri来表示的， 有三种方式来指定一个Pyro对象的uri:</p>
<ol>
<li><p>直接使用Pyro对象的uri</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri_string = <span class="string">"hello.test@server-desktop:9999"</span></span><br></pre></td></tr></table></figure>
<p> 这个uri就是上面的服务端例子输出的uri， 可以直接使用。</p>
</li>
<li><p>使用对象名称去Pyro name server进行查询</p>
<p>方式1的uri包含了很多个部分，它们唯一标识了这个Pyro的对象，但是很多时候我们并不关心这个对象服务被部署在哪个Host， 哪个Port。 我们希望只要知道这个对象的名字就可以直接调用它。 这有点类似于即插即用的概念， 就像我们访问google的时候，只要记住了google的域名， 不知道他的IP地址也可以访问， 哪怕有一天google的实际IP改变了， 我们也不需要去关心。</p>
<p>很显然， 我们需要一个名称服务器（name server）来帮助我们完成这件事， 听起来很像域名服务器的样子。好吧， 这玩意完全可以看做是一个简化版的域名服务器。做个类比的话， 上面的例子中daemon.register函数返回的uri就是相当于ip地址。 对象名称就相当于域名。只要知道了域名就可以通过名称服务器查询到对象的地址uri。所幸的是Pyro已经内置了一个name server. 当服务端生成一个Pyro对象时， 同时把这个对象注册到name server上。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">hello =</span> Hello()</span><br><span class="line"><span class="variable">daemon=</span>Pyro4.Daemon(<span class="variable">host=</span>'server-desktop', <span class="variable">port=</span><span class="number">9999</span>)     <span class="comment"># 创建一个Pyro的Daemon, 其中server-desktop是server</span></span><br><span class="line"><span class="variable">uri=</span>daemon.register(hello)                 <span class="comment"># 把hello对象注册到Pyro的Daemon</span></span><br><span class="line"><span class="variable">ns=</span>Pyro4.locateNS()                        <span class="comment"># 创建name server对象</span></span><br><span class="line">ns.register(<span class="string">"hello.object.test"</span>, uri)      <span class="comment"># 把uri注册到name server并且起一个便于记忆的名字hello.object.test</span></span><br><span class="line">daemon.requestLoop()                       <span class="comment"># 启动Daemon并等待客户端的调用指令。</span></span><br></pre></td></tr></table></figure>
<p>客户端可以通过name server来查询到名字为<code>hello.object.test</code>的真正地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pyro4</span><br><span class="line">nameserver = Pyro4.locateNS()</span><br><span class="line">uri_string = nameserver.lookup(<span class="string">"hello.object.test"</span>)   <span class="comment"># 查询到hello.object.test的uri</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用对象名字，让Pyro自动查询。</p>
<p>就如同访问一个网站既可以用ip访问也可以用域名访问一样，Pyro对象也可以通过指定对象名字来直接访问</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri_string = <span class="string">"PYRONAME:hello.object.test"</span></span><br></pre></td></tr></table></figure>
<p>有了这种简单的方式，还有什么理由还要去用第二种方式呢？ 好吧， 如果只采用默认的查询，确实没有必要用方式2。因为方式2就是方式3的内部实现。</p>
</li>
</ol>
<p>有了远程对象的uri， 就可以创建Pyro对象了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj = Pyro4.Proxy(uri_string )</span><br></pre></td></tr></table></figure></p>
<p>Pyro对象创建完成后，就可以访问Pyro对象的属性和方法了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.attr <span class="comment"># access attribute</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.sayHello()    <span class="comment"># access method</span></span><br><span class="line"><span class="string">'Hello, welcom to server-desktop.'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>obj.calcMD5(<span class="string">'abc'</span>)</span><br><span class="line"><span class="string">'900150983cd24fb0d6963f7d28e17f72'</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到调用方式与调用本地对象没有任何差别。值得注意的是<code>sayHello</code>方法返回的是<em>server-desktop</em>， 表明这个函数确实是在server端运行的。</p>
<h3 id="名称服务器">名称服务器</h3><p>如果你用的uri指定方式是2或者3的话，上面的例子有可能不会成功。 因为还没有运行name server。 你的Pyro对象的名字无法注册也无法解析。用下面的命令启动名称服务器<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python -m <span class="constant">Pyro4.</span>naming</span><br></pre></td></tr></table></figure></p>
<p>这个服务器可以运行在<strong>Local Network</strong>的任意一个Host之上。 需要注意的是Pyro的名称服务器实际上也是一个远程对象，只不过它的uri可以通过一个特定格式的<em>UDP广播</em>来获取。</p>
<h3 id="2014-3-4更新">2014-3-4更新</h3><p>发现搭建在<code>Raspberry Pi</code>上的Pyro服务有时候访问不到， 于是针对Pyro指定uri的第三种方式， 做了一些源码分析：</p>
<ol>
<li><p>Pyro针对protocol是<code>PYRONAME</code>的情况， 会在访问object的方法、属性之前解析object的地址， 解析完成后， 会把这个地址记录到这个object中， 只要这个对象不被销毁，下次的访问不会再次触发名称解析。</p>
</li>
<li><p>Pyro在访问对象属性，方法之前， 如果发现对象uri的协议是PYRONAME，会调用Pyro4.naming对象的resolve函数去解析这个名字，这个过程完全等同上述第二种指定uri方式。 resolve函数的工作流程如下：</p>
<ul>
<li>用locateNS()获取Name Server的Pyro对象。</li>
<li>再调用Name Server对象的lookup()函数获取所要访问对象的uri。</li>
</ul>
</li>
<li><p>locateNS开始会先向<code>Pyro4.config.NS_HOST</code>查询（默认是localhost）， 如果没有这个地址不存在或者查询不到， 会发UDP广播来查询Name Server的地址，格式：</p>
<pre><code>GET_NSURI
</code></pre><p> 如果网络上存在Pyro的Name Server，会得到返回的Name Server的uri：</p>
<pre><code><span class="tag">PYRO</span><span class="pseudo">:Pyro</span><span class="class">.NameServer</span><span class="at_rule">@<span class="keyword">&lt;name-server-ip&gt;:9090</span></span>
</code></pre><p> locateNS返回Name Server的Pyro对象</p>
</li>
</ol>
<p>前面提到的Pyro服务有时访问不到的情况，最后发现是RPi上的USB无线网卡Packet Loss比较严重， 特别对于inbound的封包， 不是每次都能收到， 看来只能换网卡解决了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> <a href="https://pythonhosted.org/Pyro4/">Pyro4</a>是一个能够通过网络来调用远程Python对象的库， 因为是纯Python实现的，具有良好的跨平台的特性， 可以用于分布式计算。这个库同时支持Python2与Python3。<br>]]>
    
    </summary>
    
      <category term="IPC" scheme="http://yoursite.com/tags/IPC/"/>
    
      <category term="Pyro" scheme="http://yoursite.com/tags/Pyro/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数声明的缺失引发的Segmentation fault]]></title>
    <link href="http://yoursite.com/2013/10/11/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%BC%95%E5%8F%91%E7%9A%84Segmentation%20fault/"/>
    <id>http://yoursite.com/2013/10/11/函数声明的缺失引发的Segmentation fault/</id>
    <published>2013-10-11T05:46:17.000Z</published>
    <updated>2015-03-12T15:38:01.431Z</updated>
    <content type="html"><![CDATA[<p>今天在安装<code>tclhttpd</code>时发现一个<em>Segmentation fault</em>的问题。<code>tclhttpd</code>里有一个Tcl的C扩展libcrypt1.0.so，似乎是用于http的认证的。 这个扩展调用了glibc的<code>crypt()</code>函数。这个扩展在32位系统编译运行都正常。换到64位系统，编译成功，但字符串指针访问返回值就会发生<em>Segmentation fault</em>错误。<br><a id="more"></a><br>经过一番调查之后，发现Tcl扩展的源文件src/crypt.c没有把包含<em>crypt()</em>函数声明的crypt.h给include进来。注意这里的crypt.h是glibc的一个头文件。 当加入下面一行代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;crypt.h&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>问题得到解决。</p>
<p>猜想由于没有函数声明，crypt函数隐含的返回类型是int型，但实际上是返回<code>char*</code>，在32位系统上，int和pointer的长度都是4bytes，而x64系统上， int长度还是4bytes，但是pointer的长度却是8bytes。 当crypt函数返回时，返回的64位指针被强制转换成了32位的int然后又被赋值给了64位的char指针，这时候的指针已经不是原来的64位指针了，高32bit被截断， 所以导致了错误。</p>
<p>为了证实这个想法，打印出返回的字符串指针：<br>当有<code>#include&lt;crypt.h&gt;</code>时，crypt函数返回的值是0x7f80233b3200，是一个64bit的指针类型。<br>去掉<code>#include&lt;crypt.h&gt;</code>时，crypt函数返回的值是 0x1ac47200，只剩下32bit了，显然是错误的。</p>
<p>再来看下objdump反汇编的结果</p>
<pre><code>$ objdump -<span class="keyword">d</span> libcrypt1.0.<span class="keyword">so</span>
</code></pre><p>当有#include&lt;crypt.h&gt;时<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7c5:   <span class="number">48</span> 8b <span class="number">00</span>                <span class="keyword">mov</span>    (%<span class="literal">rax</span>),%<span class="literal">rax</span></span><br><span class="line">7c8:   <span class="number">48</span> <span class="number">89</span> d6                <span class="keyword">mov</span>    %<span class="literal">rdx</span>,%<span class="literal">rsi</span></span><br><span class="line">7cb:   <span class="number">48</span> <span class="number">89</span> c7                <span class="keyword">mov</span>    %<span class="literal">rax</span>,%<span class="literal">rdi</span></span><br><span class="line">7ce:   e8 <span class="number">4d</span> fe ff ff          callq  <span class="number">620</span> &lt;crypt@plt&gt;</span><br><span class="line">7d3:   <span class="number">48</span> <span class="number">89</span> <span class="number">45</span> f8             <span class="keyword">mov</span>    %<span class="literal">rax</span>,-<span class="number">0x8</span>(%<span class="literal">rbp</span>)</span><br></pre></td></tr></table></figure></p>
<p>去掉#include&lt;crypt.h&gt;时<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7c5:   <span class="number">48</span> 8b <span class="number">00</span>                <span class="keyword">mov</span>    (%<span class="literal">rax</span>),%<span class="literal">rax</span></span><br><span class="line">7c8:   <span class="number">48</span> <span class="number">89</span> d6                <span class="keyword">mov</span>    %<span class="literal">rdx</span>,%<span class="literal">rsi</span></span><br><span class="line">7cb:   <span class="number">48</span> <span class="number">89</span> c7                <span class="keyword">mov</span>    %<span class="literal">rax</span>,%<span class="literal">rdi</span></span><br><span class="line">7ce:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span>    <span class="number">$0</span>x0,%<span class="number">eax</span></span><br><span class="line">7d3:   e8 <span class="number">48</span> fe ff ff          callq  <span class="number">620</span> &lt;crypt@plt&gt;</span><br><span class="line">7d8:   <span class="number">48</span> <span class="number">98</span>                   cltq</span><br><span class="line">7da:   <span class="number">48</span> <span class="number">89</span> <span class="number">45</span> f8             <span class="keyword">mov</span>    %<span class="literal">rax</span>,-<span class="number">0x8</span>(%<span class="literal">rbp</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到当没有函数声明时，多了一个很陌生的<strong>cltq</strong>指令，查了下这条指令， 原来是eax的符号扩展指令，如果eax的最高位为1的话，符号扩展后rax的高32bit全为1，而如果eax的最高位为0的话，则扩展出来rax的高32bit全为0。 终于真相大白。同时发现前面说所的一大段转换过程：<u>返回的64位指针被强制转换成了32位的int然后又被赋值给了64位的char指针</u>，居然只用了一条汇编指令来实现。</p>
<p>其实gcc早就给出了警告:</p>
<pre><code>./src/crypt.c:<span class="number">63</span>:<span class="number">14</span>: warning: <span class="keyword">cast</span> to <span class="type">pointer</span> <span class="keyword">from</span> integer <span class="keyword">of</span> different size [-<span class="type">Wint</span>-to-<span class="type">pointer</span>-<span class="keyword">cast</span>]
</code></pre><p>只是当时没有注意到，可能源文件编译警告太多也是没有注意到的一个原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天在安装<code>tclhttpd</code>时发现一个<em>Segmentation fault</em>的问题。<code>tclhttpd</code>里有一个Tcl的C扩展libcrypt1.0.so，似乎是用于http的认证的。 这个扩展调用了glibc的<code>crypt()</code>函数。这个扩展在32位系统编译运行都正常。换到64位系统，编译成功，但字符串指针访问返回值就会发生<em>Segmentation fault</em>错误。<br>]]>
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="GCC" scheme="http://yoursite.com/tags/GCC/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Segmentation fault" scheme="http://yoursite.com/tags/Segmentation-fault/"/>
    
      <category term="x86_64" scheme="http://yoursite.com/tags/x86-64/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NAT及其穿透技术浅析]]></title>
    <link href="http://yoursite.com/2012/08/17/NAT%E5%8F%8A%E5%85%B6%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2012/08/17/NAT及其穿透技术浅析/</id>
    <published>2012-08-17T07:14:34.000Z</published>
    <updated>2015-05-19T09:01:35.430Z</updated>
    <content type="html"><![CDATA[<p>NAT(Network Address Translation) 网络地址转换技术被普遍用于有多台主机但只有一个IP地址能访问Internet的网络中。它是作为一种IPv4地址短缺的临时解决方案而产生的，但随着家用WiFi路由器的普及而变的流行起来。<br><a id="more"></a><br>在我看来，NAT存在的意义不只是解决IP地址的短缺，还与运营商的计费模式有相当大的关系。即使在IP地址数目多如恒河沙数的IPv6时代，如果运营商只按IP地址数目来计费，NAT技术依然不会消亡。</p>
<p>NAT将网络分为本地网络和外部网络两个部分，内部本地网络(LAN)和外部广域网络(WAN)。内部网络是一个私有的网络， 任何内网主机的IP地址都不会传输到外部网络。内网主机发送到外网主机的数据包，源地址和端口会被NAT修改，实际上NAT充当了内部网络的代理功能。</p>
<p>与翻译语言用的词典类似，NAT也需要维护一张NAT的映射表。这张表记载了内部IP地址/端口与外部IP地址/端口的映射。除静态NAT之外，与词典有所不同的是，NAT的映射可以是动态建立的， 建立的规则根据NAT的类型有所不同（详见下文）。 </p>
<p>NAT映射的生命期是与NAT Session保持一致的。一个NAT映射建立绑定到移除的这一段时间称之为NAT Session。 NAT映射的移除是由超时机制触发的，如果规定的一段时间之内，没有符合某条映射的数据包通过， 那么这个NAT映射就会从表格中移除。从而释放外部的地址、端口等资源用来建立新的映射。对于TCP来说， TCP Session的结束也会触发NAT映射的移除。</p>
<blockquote>
<p>以下图例中矩形方块表示一个IP地址，半圆表示一个端口。</p>
</blockquote>
<h1 id="静态NAT">静态NAT</h1><p>这种NAT只是简单的网络地址转换，并不涉及到端口的映射。NAT表一般是手工配置，每一项都包含内网地址和外网地址的一个映射，如下表（Z为外部IP地址）</p>
<table>
<thead>
<tr>
<th style="text-align:center">Internal IP</th>
<th style="text-align:center">External IP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">Z1</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">Z2</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">Z3</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-static-dynamic.png-watermark" alt="static/dynamic nat"></p>
<p>一个内部IP地址要与外部通信，经过NAT之后，数据包的源地址会被修改为与之对应的一个外部IP地址.  如果有响应的数据包返回， 经过NAT之后， 响应包的目的IP地址会被修改为原来的内部地址IP。因为这些映射是一一对应的，外部网的​主机也可以直接与内网的主机通信。</p>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-data-flow.png-watermark" alt="nat-data-flow"></p>
<p>显然，静态NAT并没有起到节省外部IP地址的作用。</p>
<h1 id="动态NAT">动态NAT</h1><p>NAT表的结构与静态NAT完全相同， 区别仅在于NAT映射是动态建立的。NAT会维护一个用于外部端口的IP地址池。 每当有内网主机向外部发出访问请求数据包时，这个内网主机的IP地址就会自动分配到一个外部IP地址与其对应，这样一个NAT映射就建立起来了。之后一段时间内所有相同主机发出的数据包都会根据这个映射，将源IP地址转换到相同的外部IP地址与外部网络的主机通信。这样可以达到一定程度的节省外部IP地址的目的。 </p>
<p>动态NAT的缺点是一个内网主机对应的外部地址不是固定的，所以外网主机在知道这个映射的外部IP地址之前，是没有办法主动和内网主机进行通信的。</p>
<h1 id="网络地址端口转换_(NAPT)">网络地址端口转换 (NAPT)</h1><p>上述<strong>静态NAT</strong>和<strong>动态NAT</strong>才是货真价实的NAT。 但一个显而易见的缺点是外部IP地址是有限的，在同一时间能访问外部网络的内网主机数量等同于外部IP地址的数量。如果内网主机数量超过外部IP地址的数目，要维持所有内网主机与外界的通信，需要满足下面2个条件：</p>
<ul>
<li>NAT表能够动态更新</li>
<li>内网主机交替与外界通信</li>
</ul>
<p><strong>动态NAT</strong>已经解决了第一个条件， 但是第二个条件需要内网用户自己协调，这会严重影响用户体验。我们注意到当一个内网主机地址试图与外界通信时，65535个端口实际上只有几个端口是正真用于传输数据的，其余的都处于空闲状态。所以如果将NAT加入端口映射的条件，同一时间可以做的映射数量可以大幅增加， 这意味着，更多的内网主机可以同时与外部通信。 加入端口映射的NAT称之为NAPT(Network Address Port Translation)，即网络地址端口转换。现在讲到NAT绝大多数都指的都是NAPT。</p>
<p>这是NAPT的NAT映射表的结构（Z为外部IP地址）</p>
<table>
<thead>
<tr>
<th style="text-align:center">Internal IP/Port</th>
<th style="text-align:center">External IP/Port</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A/2001</td>
<td style="text-align:center">Z/2001</td>
</tr>
<tr>
<td style="text-align:center">B/2001</td>
<td style="text-align:center">Z/2002</td>
</tr>
<tr>
<td style="text-align:center">B/3000</td>
<td style="text-align:center">Z/3000</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>因为外部端口数量有65535个之多，所以通常只要一个外部IP就可以完成一个小型的内部网络访问外部网络的需求。 这也是家庭无线路由器能够让所有的内网主机，移动设备同时共享上网的原理。</p>
<p><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnapt-data-flow.png-watermark" alt="static/dynamic nat"></p>
<p>NAPT的NAT表项通常也是动态的建立的，根据<strong>NAT映射的建立规则</strong>， NAPT可以划分为2类</p>
<ul>
<li><a href="#cone-nat">锥型NAT (Cone NAT)</a></li>
<li><a href="#symmetric-nat">对称型NAT (Symmetric NAT)</a></li>
</ul>
<p><a name="cone-nat"></a></p>
<h2 id="锥型NAT_(Cone_NAT)">锥型NAT (Cone NAT)</h2><p>这种类型的NAT根据内部数据包的源IP地址和端口号，分配一个独立的外部端口。所有源于相同内部IP地址和端口的数据包都会映射到同一个外部地址和端口。</p>
<p>锥型NAT根据目的地址或者<strong>目的主机的受限规则</strong>可以分为3类：</p>
<ul>
<li>完全锥型NAT (Full-cone NAT)</li>
<li>地址受限的锥型NAT (Address Restricted NAT)</li>
<li>端口受限的锥型NAT (Port Restricted NAT)</li>
</ul>
<h4 id="完全锥型NAT_(Full-cone_NAT)">完全锥型NAT (Full-cone NAT)</h4><p>一旦内网主机A/P通过NAT映射到了外部的地址Z和端口P’，任何外部的主机使用任何源端口都可以向Z/P’发起连接，数据都会被传回先前的内网主机A/P。<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-full-cone.png-watermark" alt="full cone nat"></p>
<h4 id="地址受限的锥型NAT_(Address_Restricted_NAT)">地址受限的锥型NAT (Address Restricted NAT)</h4><p>一旦内网主机A/P通过NAT映射到了外部的地址Z和端口P’，只有A/P访问过的外部的主机才可以向Z/P’发起连接，并且可以使用任意的源端口，数据都会被传回先前的内网主机A/P。<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-cone-address.png-watermark" alt="address restricted nat"></p>
<h4 id="端口受限的锥型NAT_(Port_Restricted_NAT)">端口受限的锥型NAT (Port Restricted NAT)</h4><p>一旦内网主机A/P通过NAT映射到了外部的地址Z和端口P’，只有A/P访问过的外部的主机才可以向Z/P’发起连接，并且源端口必须是A/P访问过的端口，数据都会被传回先前的内网主机A/P。这种类型的NAT隐含了地址受限的条件，还加上了端口限制。</p>
<p>绝大部分家庭路由器使用的NAT都是这种类型的。<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-cone-port.png-watermark" alt="port restricted nat"></p>
<p><a name="symmetric-nat"></a></p>
<h1 id="对称型NAT_(Symmetric_NAT)">对称型NAT (Symmetric NAT)</h1><p>Cone类型的NAT的映射的建立只根据内部源IP和源端口来进行，而对称类型的NAT则会加入目的IP地址和目的端口的条件。<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocnat-symmetric.png-watermark" alt="symmetric nat"><br>对于相同的内部IP地址和相同源端口发出的2个数据包，如果目的地址或者目的端口不同，Cone类型的NAT也会映射到相同的外部端口。 而对称类型的NAT则会映射到两个不同的外部端口。</p>
<blockquote>
<p>注意对称类型的NAT与Cone类型的划分是根据映射<strong>建立规则</strong>来确立的，而不是外网主机的<strong>受限规则 </strong>，这两个规则是独立的。</p>
</blockquote>
<p>对称型NAT的外网主机受限机制与<strong>端口受限的锥形NAT</strong>完全相同，不在赘述。</p>
<p>对称型NAT的因其安全系数比较高，一般为企业所有采用。</p>
<h1 id="应用程序网关ALG">应用程序网关ALG</h1><p>绝大多数的应用都可以顺利的通过NAPT访问外部服务， 但凡事总有特例，考虑下面两种情况：</p>
<ul>
<li>外网主机要求接收到的数据包使用特定的源端口， 但NAT的作用下映射端口不能保证跟源端口相同。比如，如果同时有两个内网主机发出的数据包具有相同的源端口，NAT将会把其中一个数据包的源端口映射到一个不同的外部端口用以区分他们。</li>
<li>内网主机发出的数据包应用层数据带有内网的IP地址或者端口的信息， 这些信息会用于外网主机主动访问内网主机，比如FTP的Active模式。</li>
</ul>
<p>这样就影响了外部主机与内部主机的通信。这时候就要用到ALG(Application Gateway)应用层网关了， ALG机制实际上就是针对各种协议做特殊处理。</p>
<ul>
<li>对于第一种情况： 让NAT依然映射到相同的外部端口， 但是在内部建立这个应用专用的映射，根据具体的协议信息来决定响应数据包应该发送到哪一个内网主机。</li>
<li>对于第二种情况： 分析协议，然后根据NAT映射修改应用层部分的IP地址和端口信息。</li>
</ul>
<p>常见的需要用到ALG的应用有RTSP，SIP，H.323, FTP, POP3, SMTP等。<br>随着互联网对数据安全性的重视，ALG分析不了加密的报文数据，而且对新的协议需要NAT设备升级来支持，所以ALG的局限性很大。</p>
<h1 id="NAT穿透">NAT穿透</h1><p>在NAT的作用下，由于外网主机没有办法主动向内网主机发起连接，使得内网主机免受到外网的攻击，形成一个天然的防火墙。但是这也阻碍了外网对内网的正常访问。 于是就有了多种多样的NAT穿透机制。</p>
<p>假设A，B为主机，S为辅助穿透用的具有外网地址的服务器， 现在主机B要访问主机A。<br>注意以下描述中<strong>有外网地址</strong>的情况也包含了<strong>静态NAT</strong>的情况，Full-cone NAT包含了Dynamic NAT的情况。</p>
<ol>
<li><p>A处于外网有外网地址<br> 无论B在NAT内网还是有外网地址，B都能直接访问到A。<br> （这种情况不属于NAT穿透的讨论范围，放到这里仅作为对比）</p>
</li>
<li><p>A处于NAT类型为Full-cone的内网中<br> A需要定时发heartbeat到S,  使S获知A的NAT外部地址。</p>
<p>无论B在NAT内网还是有外网地址，B向S发出穿透请求，S将A的NAT外部地址和端口告诉B，因为A不限制来源地址和来源端口，然后B就能直接访问到A。</p>
</li>
<li><p>A处于NAT类型为Address-restricted的内网中<br> A需要定时发heartbeat到S， 使S获知A的NAT外部地址。</p>
<p> 3.1. 若B有外网地址或者为Full-cone。B向S发出穿透请求，S转发B的地址到A， A直接访问B的地址建立起NAT映射，B因为不限制来源地址和端口，所以能收到A的数据包，自然就能获知A的外网地址和端口，B当然也可以访问A了。</p>
<p> 3.2. 若B处于NAT类型为Address-restricted的内网中。B向S发出穿透请求， S转发B的外网地址/端口到A， S也转发A的外网地址/端口到B，然后A, B各自向对方的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却分别取消了相互的地址/端口限制。至此A和B就可以互访了，而且无论谁先访问谁，各自的源端口都可以是任意端口。</p>
<p> 3.3. 若B处于NAT类型为Port-restricted的内网中。B向S发出穿透请求， S转发B的外网地址/端口到A， S也转发A的外网地址/端口到B，然后A, B各自向对方的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却分别取消了相互的地址/端口限制。至此A和B就可以互访了。注意因为B是限制端口的，A先访问B的话，源端口必须和heartbeat通信端口一致。 而A是不限制端口的，所以B先访问A的话，可以用任意源端口。</p>
<p> 3.4. 若B处于NAT类型为Symmetric的内网中。B向S发出穿透请求， S转发B的外网地址/端口到A， S也转发A的外网地址/端口到B，然后A先向B的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却取消了对B的地址限制。至此B就可以访问A了。 </p>
<blockquote>
<p>与上述3.2, 3.3情况的唯一不同的是这里A无法先主动访问B，因为B的外网端口无法知道。若只需要B主动访问A，上述两种情况也可以统一用这种方式解决.</p>
</blockquote>
</li>
<li><p>A处于NAT类型为Port-restricted的内网中<br> A需要定时发heartbeat到S， 使S获知A的NAT外部地址。</p>
<p> 4.1. 若B有外网地址或者为Full-cone。B向S发出穿透请求，S转发B的地址到A， A直接访问B的地址建立起NAT映射，B因为不限制来源地址和端口，所以能收到A的数据包，自然就能获知A的外网地址和端口，B当然也可以访问A了。(同3.1)</p>
<p> 4.2. 若B处于NAT类型为Address-restricted的内网中。B向S发出穿透请求， S转发B的外网地址/端口到A， S也转发A的外网地址/端口到B，然后A, B各自向对方的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却分别取消了相互的地址/端口限制。至此A和B就可以互访了，注意因为A是限制端口的，B先访问A的话，源端口必须和heartbeat通信端口一致。 而B是不限制端口的，所以A先访问B的话，可以用任意源端口。（同3.3)</p>
<p> 4.3. 若B处于NAT类型为Port-restricted的内网中。B向S发出穿透请求， S转发B的外网地址/端口到A， S也转发A的外网地址/端口到B，然后A, B各自向对方的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却分别取消了相互的地址/端口限制。至此A和B就可以互访了。注意因为A, B都是限制端口的，相互访问的源端口都必须和各自的heartbeat通信端口一致。 </p>
<p> 4.4. 若B处于NAT类型为Symmetric的内网中。S转发A的外网地址/端口到B， B向A的外网地址/端口发一个访问请求, 但是Symmetric会对不同的目的地址/端口改变外网端口号，这时候B的外网端口是能不确定的（一定和heartbeat通信端口不同），而A又需要B的<strong>新</strong>的外网端口来解除对B的端口限制，这里就产生了一个死锁。解决的方式基本靠<em>猜</em>B的外网端口号，比如+1。</p>
</li>
<li><p>A处于NAT类型为Symmetric的内网中</p>
<p> 5.1. 若B有外网地址或者为Full-cone。B向S发出穿透请求，S转发B的地址到A， A直接访问B的地址建立起NAT映射，B因为不限制来源地址和端口，所以能收到A的数据包，自然就能获知A的外网地址和端口，B当然也可以访问A了。(同3.1)</p>
<p> 5.2. 若B处于NAT类型为Address-restricted的内网中。B向S发出穿透请求， S转发A的外网地址/端口到B， S也转发B的外网地址/端口到A，然后B先向A的外网地址/端口发一个访问请求（源端口要与heartbeat通信端口一致，这样可以保证映射到的外网端口应该也一致），虽然访问不成功，却取消了对A的地址限制。至此A就可以访问B了, B就可以知道A的新的外网端口，自然也能访问A了。 （同3.4）</p>
<p> 5.3. <a name="tranversal-53"></a>若B处于NAT类型为Port-restricted的内网中。S转发A的外网地址/端口到B， A向B的外网地址/端口发一个访问请求, 但是Symmetric会对不同的目的地址/端口改变外网端口号，这时候A的外网端口是能不确定的（一定和heartbeat通信端口不同），而B又需要A的<strong>新</strong>的外网端口来解除对A的端口限制，这里就产生了一个死锁。解决的方式基本靠<em>猜</em>A的外网端口号，比如+1。（同4.4）</p>
<p> 5.4. <a name="tranversal-54"></a>若B处于NAT类型为Symmetric的内网中。双方都不知道对方的新端口，<strong>无法直接通信</strong>。所有的数据只能通过有外网地址的服务器中转，开销大，效率低下（见TURN部分）。</p>
</li>
</ol>
<p>尽管TCP也可以用来做NAT穿透，由于NAT穿透很多情况只需要发一个数据包来解除端口地址的限制，实际应用中使用无连接的UDP更加方便。</p>
<p>可以看到NAT穿透实现起来还是比较困难的，最方便的是让应用可以有一个外网地址可以直接访问。所以如果NAT路由器支持UPnP，NAT-PMP, PCP等协议的话，应用程序可以对需要提供连接服务的端口建立一个端口转发(Port Forwarding)的方式来获取直接被外网访问的VIP通道， 此时这个应用相当于有了一个外网地址。当然也可以手动为一个应用添加端口转发。</p>
<h1 id="STUN">STUN</h1><p>NAT穿透是基于通信的双方已经知晓如下信息的前提下进行的。</p>
<ul>
<li>双方所处NAT的类型</li>
<li>双方的外网地址和端口</li>
</ul>
<p>这些信息都可以通过STUN(RFC3489)协议来获取到，STUN的全称是Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)。上述各种NAT类型也是在STUN协议中定义的。</p>
<p>需要注意的是STUN(RFC3489)协议已经被RFC5389取代了，虽然缩写没有变，但是英文全称已经变成了Session Traversal Utilities for NAT。RFC5389是在RFC3489上发展而来的， 修改了旧协议的一些缺陷， 同时提供了TCP/TLS穿透和IPv6的支持。更重要的是，从名字可以看出来，协议的定位从原来NAT穿透完整解决方案，变成一种NAT穿透解决方案中的工具。</p>
<p>RFC5389中NAT的行为探测功能已经被独立出来作为新的RFC规范：RFC5780<br>其中NAT类型定义在RFC4787中，而且也已经废弃了原来的XXX-Cone和Symmetric的NAT类型的定义。</p>
<h1 id="TURN">TURN</h1><p>考虑通信的一方是在Symetric NAT的后面，且另外一方也是在Symetric NAT的后面(<a href="#tranversal-54">5.4</a>)或者是在Port-restricted NAT的后面(<a href="#tranversal-53">5.3</a>)时， 用传统的打洞方式很难实现NAT的穿透。 但是如果借助外网的一台服务器，问题就可以转化成2个单边是有外网地址的形式的网络。这样可以通过这台服务器的中转来实现与任何NAT网络结构的通信。 这台服务器则相当于通信双方的<em>代理</em>，或许我们可以称其为<em>NAT通信路由器</em>。</p>
<p>利用这个原理来实现NAT穿透的协议叫做TURN,  全称是Traversal Using Relay NAT，TURN和STUN一样是一个C/S结构模式的协议, 同时支持UDP的TCP的穿越。服务器负责转发客户端之间的所有通信。<br><img src="http://7ximrm.com1.z0.glb.clouddn.com/twocturn.png" alt="turn-topology"></p>
<p>TURN显而易见的缺点是服务器负担过重，容易造成网络延迟大，效率低。</p>
<h1 id="ICE">ICE</h1><p>RFC3264(An Offer/Answer Model with the Session Description Protocol)定义了一个请求/回答模式的SDP​协议. 这个协议也是SIP的基础协议。ICE协议也是RFC3264请求/回答模式的一个扩展， 全称Interactive Connectivity Establishment。 这种NAT穿透协议利用了现有的STUN协议和TURN协议，结合了两者的优点。ICE不需要通信终端去判断NAT的存在或者类型，只在最坏的情况下，比如两边都是对称NAT，才会用到TURN转发数据。</p>
<h1 id="各种NAT类型的比较">各种NAT类型的比较</h1><table>
<thead>
<tr>
<th>NAT类型</th>
<th>NAT映射建立规则</th>
<th>目的主机受限规则</th>
<th>NAT穿透</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态NAT</td>
<td>源IP（静态配置）</td>
<td>不限制</td>
<td>简单</td>
</tr>
<tr>
<td>动态NAT</td>
<td>源IP</td>
<td>不限制</td>
<td>简单</td>
</tr>
<tr>
<td>完全锥型NAT</td>
<td>源IP/源端口</td>
<td>不限制</td>
<td>简单</td>
</tr>
<tr>
<td>地址受限的锥型NAT</td>
<td>源IP/源端口</td>
<td>IP受限制</td>
<td>一般</td>
</tr>
<tr>
<td>端口受限的锥型NAT</td>
<td>源IP/源端口</td>
<td>IP和端口受限制</td>
<td>困难</td>
</tr>
<tr>
<td>对称型NAT</td>
<td>源IP/源端口/目的IP/目的端口</td>
<td>IP和端口受限制</td>
<td>非常困难</td>
</tr>
</tbody>
</table>
<h1 id="参考文献">参考文献</h1><ul>
<li><a href="https://tools.ietf.org/html/rfc2663" target="_blank" rel="external">NAT RFC2663</a></li>
<li><a href="https://www.ietf.org/rfc/rfc3489.txt" target="_blank" rel="external">STUN RFC3489</a></li>
<li><a href="https://tools.ietf.org/html/rfc5389" target="_blank" rel="external">STUN RFC5389</a></li>
<li><a href="https://tools.ietf.org/html/rfc6062" target="_blank" rel="external">TURN RFC6062</a></li>
<li><a href="https://tools.ietf.org/html/rfc5245" target="_blank" rel="external">ICE RFC5245</a></li>
<li><a href="https://tools.ietf.org/html/rfc5780" target="_blank" rel="external">NAT Behavior Discovery RFC5780</a></li>
<li><a href="http://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="external">WiKi NAT</a></li>
</ul>
<p>(原创文章，转载请标注来源和作者)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>NAT(Network Address Translation) 网络地址转换技术被普遍用于有多台主机但只有一个IP地址能访问Internet的网络中。它是作为一种IPv4地址短缺的临时解决方案而产生的，但随着家用WiFi路由器的普及而变的流行起来。<br>]]>
    
    </summary>
    
      <category term="NAT" scheme="http://yoursite.com/tags/NAT/"/>
    
      <category term="NAT穿透" scheme="http://yoursite.com/tags/NAT%E7%A9%BF%E9%80%8F/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
  </entry>
  
</feed>